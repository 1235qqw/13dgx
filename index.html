<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>4 в ряд с ИИ Minimax</title>
  <style>
    body { font-family: Arial; display: flex; flex-direction: column; align-items: center; margin: 20px; }
    #board { display: grid; grid-template-columns: repeat(7, 60px); gap: 5px; margin: 20px; }
    .cell { width:60px; height:60px; background:#00aaff;border-radius:10px;cursor:pointer;display:flex;justify-content:center;align-items:center; }
    .piece { width:50px; height:50px; border-radius:50%; }
    .red { background:red; } .yellow { background:yellow; }
    #status { font-size:18px; }
    button { padding:8px 16px; margin-top:10px; }
  </style>
</head>
<body>
  <h1>4 в ряд (ИИ Minimax)</h1>
  <div id="board"></div>
  <div id="status">Ты ходишь (красный)</div>
  <button onclick="resetGame()">Сбросить</button>

  <script>
    const ROWS = 6, COLS = 7, DEPTH = 4;
    let board = [], gameOver = false, playerTurn = true;
    const boardDiv = document.getElementById('board'), status = document.getElementById('status');

    function createBoard(){
      boardDiv.innerHTML = '';
      board = Array.from({length: ROWS}, () => Array(COLS).fill(null));
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.row = r; cell.dataset.col = c;
          cell.onclick = () => { if(playerTurn && !gameOver) makeMove(c, 'red'); };
          boardDiv.appendChild(cell);
        }
      }
    }

    function makeMove(col, color){
      const row = getNextRow(col);
      if(row < 0) return;
      board[row][col] = color;
      updateBoard();
      if(checkWin(row,col,color)){ endGame(color==='red' ? 'Ты победил!' : 'ИИ победил!'); return; }
      if(isFull()){ endGame('Ничья'); return; }
      playerTurn = (color === 'yellow');
      status.textContent = playerTurn ? 'Ты ходишь (красный)' : 'ИИ думает...';
      if(!playerTurn) setTimeout(botThink, 200);
    }

    function getNextRow(col){
      for(let r=ROWS-1;r>=0;r--) if(!board[r][col]) return r;
      return -1;
    }

    function updateBoard(){
      document.querySelectorAll('.cell').forEach(cell => {
        const r = +cell.dataset.row, c = +cell.dataset.col;
        cell.innerHTML = '';
        if(board[r][c]){
          const p = document.createElement('div');
          p.classList.add('piece', board[r][c]);
          cell.appendChild(p);
        }
      });
    }

    function botThink(){
      const {col} = minimax(board, DEPTH, -Infinity, Infinity, true);
      makeMove(col, 'yellow');
    }

    function minimax(bd, depth, alpha, beta, maximizing){
      if(depth===0 || isTerminal(bd)){
        return {score: evaluate(bd)};
      }
      if(maximizing){
        let max = {score:-Infinity, col: null};
        for(let c=0;c<COLS;c++){
          const r = getNextRowCol(bd, c);
          if(r<0) continue;
          const tmp = copyBoard(bd); tmp[r][c]='yellow';
          const result = minimax(tmp, depth-1, alpha, beta, false);
          if(result.score > max.score) max = {score: result.score, col: c};
          alpha = Math.max(alpha, max.score);
          if(beta <= alpha) break;
        }
        return max;
      } else {
        let min = {score:Infinity, col: null};
        for(let c=0;c<COLS;c++){
          const r = getNextRowCol(bd, c);
          if(r<0) continue;
          const tmp = copyBoard(bd); tmp[r][c]='red';
          const result = minimax(tmp, depth-1, alpha, beta, true);
          if(result.score < min.score) min = {score: result.score, col: c};
          beta = Math.min(beta, min.score);
          if(beta <= alpha) break;
        }
        return min;
      }
    }

    function getNextRowCol(bd, col){
      for(let r=ROWS-1;r>=0;r--) if(!bd[r][col]) return r;
      return -1;
    }

    function copyBoard(bd){
      return bd.map(row => row.slice());
    }

    function isTerminal(bd){
      return checkWinBoard(bd,'red')||checkWinBoard(bd,'yellow')|| bd.every(r=>r.every(c=>c));
    }

    function checkWinBoard(bd, color){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(bd[r][c]===color && checkWin(r,c,color,bd)) return true;
        }
      }
      return false;
    }

    function checkWin(row,col,color,bd=board){
      const dirs = [[[0,1],[0,-1]],[[1,0],[-1,0]],[[1,1],[-1,-1]],[[1,-1],[-1,1]]];
      for(const dir of dirs){
        let cnt = 1;
        for(const [dx,dy] of dir){
          let r=row+dx, c=col+dy;
          while(r>=0 && r<ROWS && c>=0 && c<COLS && bd[r][c]===color){
            cnt++; r+=dx; c+=dy;
          }
        }
        if(cnt>=4) return true;
      }
      return false;
    }

    function evaluate(bd){
      const score = (checkWinBoard(bd,'yellow')? 1000:0) - (checkWinBoard(bd,'red')? 1000:0);
      return score;
    }

    function isFull(){
      return board[0].every(c=>c);
    }

    function endGame(msg){
      status.textContent = msg;
      gameOver = true;
    }

    function resetGame(){
      gameOver = false; playerTurn = true;
      status.textContent = 'Ты ходишь (красный)';
      createBoard();
    }

    createBoard();
  </script>
</body>
</html>
